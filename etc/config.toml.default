# The notation used for
#
# * Large numbers - k = 1_000, m = 1_000_000, g = 1_000_000_000
# * Time durations - s = seconds (default if not specified), m = minutes,
#                    h = hours, d = days, w = weeks, M = months, y = years
#
[auth]
# Authenticator configuration
# Note: there can be only one authenticator configured at a time

# Basic authenticator using htpasswd file
# use htpasswd -B to create bcrypt hashed passwords
#authenticator = { kind = "htpasswd", params = { path = "htpasswd" } }

# Database authenticator (uses server database to store user accounts)
# uses server database to store user accounts
# WARNING: it is recommended to raise the minimum password length and complexity
# requirements when running in production
authenticator = { kind = "db", params = { policy = { min_length = 6, require_uppercase = false, require_lowercase = false, require_digit = false, require_special = false } } }

# LDAP authenticator
#
# * path - LDAP search base DN for user accounts (e.g. "ou=users,dc=domain,dc=com")
# * service_user - LDAP service account username (e.g. "service" or "cn=service,dc=domain,dc=com")
# * service_password - LDAP service account password
# * url - LDAP server URL (e.g. "ldap://somehost:389" or "ldaps://somehost:636")
# * provider - LDAP server provider
# * starttls - optional boolean parameter to enable STARTTLS for ldap:// URLs (default: false)
# * no_tls_verify - optional boolean parameter to disable TLS certificate verification (default: false)
# * timeout - optional connection timeout in seconds (default: 5)
# * pool_size - optional connection pool size (default: 1)
# * auth_pool_size - optional authentication connection pool size (default: 1)
#
#
# supported providers:
# * "msad" - Microsoft Active Directory
# * "authentik" - Authentik LDAP server
#
# other providers are treated as generic LDAP (RFC 4510), specify as "generic" or omit the provider parameter
# warning: for generic LDAP servers the authenticator does not check if the user account is disabled or locked
#authenticator = { kind = "ldap", params = { path = "ou=users,dc=domain,dc=com", service_user = "service", service_password = "secret", url = "ldap://somehost:389", provider = "msad" } }

# Breakin protection configuration
#
# * max_records - maximum number of remote clients to track
# * window - time window
# * ip_score - score to add for each failed attempt from the same IP address
# * user_score - score to add for each failed attempt for the same username
# * captcha_threshold - score threshold to require captcha verification
breakin_protection = { max_records = "10k", window = "10m", ip_score = 1, user_score = 1, captcha_threshold = 3 }

# Passkeys
#
# * max_auth_challenges - maximum number of allowed authentication challenges per time
# * max_reg_challenges - maximum number of allowed registration challenges per time
# * timeout - challenge validity time in seconds
# * max_auth_callenges_per_ip - maximum number of allowed authentication challenges per IP address
# * check_login_present - require the selected authenticator to confirm that the user exists (default: true)
passkeys = { max_auth_challenges = "1k", max_reg_challenges = 10, timeout = 60 }

# key_file: PKCS#8 private key in PEM format, eg. openssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:prime256v1 -out tokens.pem. Auto-generated if not present
# expire: token expiration time since the token was issued
# max_bearer_expire: maximum allowed expiration time for per-app tokens
# domain: token validation for subdomains of the specified domain, also used as rp_id for passkeys
# cookie: name of the cookie to store the token (gateryx_auth_<cookie>), default is "token"
# stick_to_ip: when true, JWTs include client IP and are only accepted when the request IP matches (default: false)
tokens = { key_file = "tokens.pem", expire = "7d", domain = "domain.local", cookie = "token" }

# authentication form web
www_root = "/var/gateryx/www/auth"

# The following user agents will always get 401 Unauthorized response with
# Basic authentication challenge, unless text/html is requested
#reply_401_to_user_agents = ["git/*", "curl/*", "Wget/*"]

[[listener]]
bind = "0.0.0.0:80"
max_clients = "1k"
max_workers = "5k"
app = "plain"

[[listener]]
bind = "0.0.0.0:443"
max_clients = "1k"
max_workers = "5k"
tls = { cert = "selfsigned.crt", key = "selfsigned.pem", protocols = ["tls1.2", "tls1.3"] }
# allows HTTP/2
protocol = "http2"
# allowed hosts/networks (ip addresses only), allowed all by default
#allow = ["127.0.0.1/32"]

[server]
http_log =  "/var/gateryx/log/access.log"
# number of master threads (responsible for logging and IDP)
master_threads = 1
# number of worker threads (responsible for processing web requests)
worker_threads = 1
max_body_size = "20m"
timeout = 5
user = "gateryx"

#[websocket_default]
#read_buffer = "16k"
#write_buffer = "16k"
#max_message_size = "40m"
#max_frame_size = "40m"

# SQLite / PostgreSQL
[db]
uri = "sqlite:///var/gateryx/db/gateryx.db"
#uri = "postgres://gateryx:xxx@192.168.1.1/gateryx"
pool_size = 10
timeout = 5

# Override default HTTP header names
#[headers]
#jwt_assertion = "X-JWT-Assertion" # JWT assertion header
#user = "X-Gateryx-User" # Current authenticated user
#real_ip = "X-Real-IP" # Real client IP address
#authorization = "X-Gateryx-Authorization" # Additional authorization header
#via = "X-Via" # Via header (returned to client)

[admin]
# key_file: PKCS#8 private key in PEM format, eg. openssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:prime256v1 -out admin.pem. Auto-generated if not present
key_file = "admin.pem"
# allowed hosts/networks (ip addresses only), no admin access by default
allow = ["127.0.0.1/32"]
# max time difference in seconds between server and client for admin requests
#max_time_diff = "5m"

# Web applications can be defined directly in the main configuration file or in
# "app.d" directory as separate files with ".toml" extension
#[[app]]
#url = "gateryx://system"
#hosts = [ "gate.domain.local" ]
#remote = "/var/gateryx/www/system"

